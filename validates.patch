From 9de5c3a7fe1bb0aeb38008b48c14c37a2148d504 Mon Sep 17 00:00:00 2001
From: Tony Petruzzi <tpetruzzi@gmail.com>
Date: Sat, 19 Jun 2010 23:59:38 -0400
Subject: [PATCH] adds validates method

---
 wheels/events/onapplicationstart/settings.cfm      |    3 +-
 wheels/model/validations.cfm                       |  495 ++++++++++++--------
 .../model/validations/low_level_validations.cfc    |    2 +-
 3 files changed, 309 insertions(+), 191 deletions(-)

diff --git a/wheels/events/onapplicationstart/settings.cfm b/wheels/events/onapplicationstart/settings.cfm
index 315ddb3..dce92ee 100644
--- a/wheels/events/onapplicationstart/settings.cfm
+++ b/wheels/events/onapplicationstart/settings.cfm
@@ -178,9 +178,10 @@
 	application.wheels.functions.validatesFormatOf = {message="[property] is invalid", allowBlank=false};
 	application.wheels.functions.validatesInclusionOf = {message="[property] is not included in the list", allowBlank=false};
 	application.wheels.functions.validatesLengthOf = {message="[property] is the wrong length", allowBlank=false, exactly=0, maximum=0, minimum=0, within=""};
-	application.wheels.functions.validatesNumericalityOf = {message="[property] is not a number", allowBlank=false, onlyInteger=false, odd="", even="", greaterThan="", greaterThanOrEqualTo="", equalTo="", lessThan="", lessThanOrEqualTo=""};
+	application.wheels.functions.validatesNumericalityOf = {message="[property] is not a number", allowBlank=false, onlyInteger=false};
 	application.wheels.functions.validatesPresenceOf = {message="[property] can't be empty"};
 	application.wheels.functions.validatesUniquenessOf = {message="[property] has already been taken", allowBlank=false};
+	application.wheels.functions.validates = {message="[property] has errors", allowBlank="", presence="", confirm="", exclusion="", inclusion="", regEx="", format="", exactly="", maximum="", minimum="", within="", numeric="", onlyInteger="", odd="", even="", greaterThan="", greaterThanOrEqualTo="", equalTo="", lessThan="", lessThanOrEqualTo=""};
 	application.wheels.functions.verifies = {handler=""};
 	application.wheels.functions.wordTruncate = {length=5, truncateString="..."};
 	application.wheels.functions.yearSelectTag = {label="", labelPlacement="around", prepend="", append="", prependToLabel="", appendToLabel="", includeBlank=false, startYear=Year(Now())-5, endYear=Year(Now())+5};
diff --git a/wheels/model/validations.cfm b/wheels/model/validations.cfm
index e464327..dbe1a26 100644
--- a/wheels/model/validations.cfm
+++ b/wheels/model/validations.cfm
@@ -1,6 +1,44 @@
 <!--- PUBLIC MODEL INITIALIZATION METHODS --->
 
 <!--- high level validation helpers --->
+<cffunction name="validates" returntype="void" access="public" output="false" hint="Validates the value(s) against a set of rules">
+	<cfargument name="properties" type="string" required="false" default="" hint="Name of property or list of property names to validate against (can also be called with the `property` argument).">
+	<cfargument name="message" type="string" required="false" hint="Supply a custom error message here to override the built-in one.">
+	<cfargument name="when" type="string" required="false" default="onSave" hint="Pass in `onCreate` or `onUpdate` to limit when this validation occurs (by default validation will occur on both create and update, i.e. `onSave`).">
+	<cfargument name="if" type="string" required="false" default="" hint="String expression to be evaluated that decides if validation will be run (if the expression returns `true` validation will run).">
+	<cfargument name="unless" type="string" required="false" default="" hint="String expression to be evaluated that decides if validation will be run (if the expression returns `false` validation will run).">
+	<cfargument name="presence" type="boolean" required="false" hint="If set to `true`, validation will be skipped if the property value is an empty string or doesn't exist at all.">
+	<cfargument name="allowBlank" type="boolean" required="false" hint="If set to `true`, validation will be skipped if the property value is an empty string or doesn't exist at all.">
+	<cfargument name="confirm" type="string" required="false" hint="when `true` validate that the value of the specified properties also has an identical confirmation value. otherwise the name of the property to confirm against">
+	<cfargument name="exclusion" type="string" required="false" hint="Single value or list of values that should not be allowed.">
+	<cfargument name="inclusion" type="string" required="false" hint="Single value or list of values that should be allowed.">
+	<cfargument name="regEx" type="string" required="false" default="" hint="Regular expression to verify against.">
+	<cfargument name="format" type="string" required="false" default="" hint="One of the following formats to verify against: `creditcard`, `date`, `email`, `eurodate`, `guid`, `social_security_number`, `ssn`, `telephone`, `time`, `URL`, `USdate`, `UUID`, `variableName`, `zipcode` (will be passed through to CFML's `isValid` function).">
+	<cfargument name="exactly" type="numeric" required="false" hint="The exact length that the property value has to be.">
+	<cfargument name="maximum" type="numeric" required="false" hint="The maximum length that the property value has to be.">
+	<cfargument name="minimum" type="numeric" required="false" hint="The minimum length that the property value has to be.">
+	<cfargument name="within" type="string" required="false" hint="A list of two values (minimum and maximum) that the length of the property value has to fall within.">
+	<cfargument name="numeric" type="numeric" required="false" hint="Specifies the value must be a number.">
+	<cfargument name="onlyInteger" type="boolean" required="false" hint="Specifies whether the property value has to be an integer.">
+	<cfargument name="odd" type="boolean" required="false" hint="Specifies the value must be an odd number.">
+	<cfargument name="even" type="boolean" required="false" hint="Specifies the value must be an even number.">
+	<cfargument name="greaterThan" type="numeric" required="false" hint="Specifies the value must be greater than the supplied value.">
+	<cfargument name="greaterThanOrEqualTo" type="numeric" required="false" hint="Specifies the value must be greater than or equal the supplied value.">
+	<cfargument name="equalTo" type="numeric" required="false" hint="Specifies the value must be equal to the supplied value.">
+	<cfargument name="lessThan" type="numeric" required="false" hint="Specifies the value must be less than the supplied value.">
+	<cfargument name="lessThanOrEqualTo" type="numeric" required="false" hint="Specifies the value must be less than or equal the supplied value.">
+	<cfargument name="unique" type="string" required="false" default="" hint="when `true` will validate that the value of the specified property is unique in the database table.">
+	<cfargument name="scope" type="string" required="false" default="" hint="One or more properties by which to limit the scope of the uniqueness constraint.">
+	<cfscript>
+		$insertDefaults(name="validates", input=arguments);
+		if (application.wheels.showErrorInformation)
+		{
+			if (Len(arguments.format) && !ListFindNoCase("creditcard,date,email,eurodate,guid,social_security_number,ssn,telephone,time,URL,USdate,UUID,variableName,zipcode", arguments.format))
+				$throw(type="Wheels.IncorrectArguments", message="The `#arguments.type#` type is not supported.", extendedInfo="Use one of the supported types: `creditcard`, `date`, `email`, `eurodate`, `guid`, `social_security_number`, `ssn`, `telephone`, `time`, `URL`, `USdate`, `UUID`, `variableName`, `zipcode`");
+		}
+		$registerValidation(methods="$validates", argumentCollection=arguments);
+	</cfscript>
+</cffunction>
 
 <cffunction name="validatesConfirmationOf" returntype="void" access="public" output="false" hint="Validates that the value of the specified property also has an identical confirmation value (common when having a user type in their email address, choosing a password etc). The confirmation value only exists temporarily and never gets saved to the database. By convention the confirmation property has to be named the same as the property with ""Confirmation"" appended at the end. Using the password example, to confirm our `password` property we would create a property called `passwordConfirmation`."
 	examples=
@@ -9,13 +47,16 @@
 		<cfset validatesConfirmationOf(property="password", when="onCreate", message="Please confirm your chosen password properly!")>
 	'
 	categories="model-initialization,validations" chapters="object-validation" functions="validatesExclusionOf,validatesFormatOf,validatesInclusionOf,validatesLengthOf,validatesNumericalityOf,validatesPresenceOf,validatesUniquenessOf">
-	<cfargument name="properties" type="string" required="false" default="" hint="Name of property or list of property names to validate against (can also be called with the `property` argument).">
-	<cfargument name="message" type="string" required="false" hint="Supply a custom error message here to override the built-in one.">
-	<cfargument name="when" type="string" required="false" default="onSave" hint="Pass in `onCreate` or `onUpdate` to limit when this validation occurs (by default validation will occur on both create and update, i.e. `onSave`).">
-	<cfargument name="if" type="string" required="false" default="" hint="String expression to be evaluated that decides if validation will be run (if the expression returns `true` validation will run).">
-	<cfargument name="unless" type="string" required="false" default="" hint="String expression to be evaluated that decides if validation will be run (if the expression returns `false` validation will run).">
-	<cfset $insertDefaults(name="validatesConfirmationOf", input=arguments)>
-	<cfset $registerValidation(methods="$validateConfirmationOf", argumentCollection=arguments)>
+	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="message" type="string" required="false" hint="See documentation for @validates.">
+	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validates.">
+	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfscript>
+		$insertDefaults(name="validatesConfirmationOf", input=arguments);
+		arguments.confirm = true;
+		validates(argumentCollection=arguments);
+	</cfscript>
 </cffunction>
 
 <cffunction name="validatesExclusionOf" returntype="void" access="public" output="false" hint="Validates that the value of the specified property does not exist in the supplied list."
@@ -25,17 +66,18 @@
 		<cfset validatesExclusionOf(property="coolLanguage", list="php,fortran", message="Haha, you can not be serious, try again please.")>
 	'
 	categories="model-initialization,validations" chapters="object-validation" functions="validatesConfirmationOf,validatesExclusionOf,validatesFormatOf,validatesInclusionOf,validatesLengthOf,validatesNumericalityOf,validatesPresenceOf,validatesUniquenessOf">
-	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="list" type="string" required="true" hint="Single value or list of values that should not be allowed.">
-	<cfargument name="message" type="string" required="false" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="allowBlank" type="boolean" required="false" hint="If set to `true`, validation will be skipped if the property value is an empty string or doesn't exist at all.">
-	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
+	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="list" type="string" required="true" hint="See documentation for @validates.">
+	<cfargument name="message" type="string" required="false" hint="See documentation for @validates.">
+	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validates.">
+	<cfargument name="allowBlank" type="boolean" required="false" hint="See documentation for @validates.">
+	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validates.">
 	<cfscript>
 		$insertDefaults(name="validatesExclusionOf", input=arguments);
-		arguments.list = $listClean(arguments.list);
-		$registerValidation(methods="$validateExclusionOf", argumentCollection=arguments);
+		arguments.exclusion = arguments.list;
+		structdelete(arguments, "list", false);
+		validates(argumentCollection=arguments);
 	</cfscript>
 </cffunction>
 
@@ -49,22 +91,19 @@
 		<cfset validatesFormatOf(property="email", regEx="^.*@.*\.se$", if="ipCheck()", unless="DayOfWeek() IS 1" message="Sorry, you must have a Swedish email address to use this website")>
 	'
 	categories="model-initialization,validations" chapters="object-validation" functions="validatesConfirmationOf,validatesExclusionOf,validatesInclusionOf,validatesLengthOf,validatesNumericalityOf,validatesPresenceOf,validatesUniquenessOf">
-	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="regEx" type="string" required="false" default="" hint="Regular expression to verify against.">
-	<cfargument name="type" type="string" required="false" default="" hint="One of the following types to verify against: `creditcard`, `date`, `email`, `eurodate`, `guid`, `social_security_number`, `ssn`, `telephone`, `time`, `URL`, `USdate`, `UUID`, `variableName`, `zipcode` (will be passed through to CFML's `isValid` function).">
-	<cfargument name="message" type="string" required="false" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="allowBlank" type="boolean" required="false" hint="See documentation for @validatesExclusionOf.">
-	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
+	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="regEx" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="type" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="message" type="string" required="false" hint="See documentation for @validates.">
+	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validates.">
+	<cfargument name="allowBlank" type="boolean" required="false" hint="See documentation for @validates.">
+	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validates.">
 	<cfscript>
 		$insertDefaults(name="validatesFormatOf", input=arguments);
-		if (application.wheels.showErrorInformation)
-		{
-			if (Len(arguments.type) && !ListFindNoCase("creditcard,date,email,eurodate,guid,social_security_number,ssn,telephone,time,URL,USdate,UUID,variableName,zipcode", arguments.type))
-				$throw(type="Wheels.IncorrectArguments", message="The `#arguments.type#` type is not supported.", extendedInfo="Use one of the supported types: `creditcard`, `date`, `email`, `eurodate`, `guid`, `social_security_number`, `ssn`, `telephone`, `time`, `URL`, `USdate`, `UUID`, `variableName`, `zipcode`");
-		}
-		$registerValidation(methods="$validateFormatOf", argumentCollection=arguments);
+		arguments.format = arguments.type;
+		structdelete(arguments, "type", false);
+		validates(argumentCollection=arguments);
 	</cfscript>
 </cffunction>
 
@@ -84,8 +123,9 @@
 	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
 	<cfscript>
 		$insertDefaults(name="validatesInclusionOf", input=arguments);
-		arguments.list = $listClean(arguments.list);
-		$registerValidation(methods="$validateInclusionOf", argumentCollection=arguments);
+		arguments.inclusion = arguments.list;
+		structdelete(arguments, "list", false);
+		validates(argumentCollection=arguments);
 	</cfscript>
 </cffunction>
 
@@ -99,21 +139,19 @@
 		<cfset validatesLengthOf(property="password", within="4,20", message="The password length has to be between 4 and 20 characters.")>
 	'
 	categories="model-initialization,validations" chapters="object-validation" functions="validatesConfirmationOf,validatesExclusionOf,validatesFormatOf,validatesInclusionOf,validatesNumericalityOf,validatesPresenceOf,validatesUniquenessOf">
-	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="message" type="string" required="false" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="allowBlank" type="boolean" required="false" hint="See documentation for @validatesExclusionOf.">
-	<cfargument name="exactly" type="numeric" required="false" hint="The exact length that the property value has to be.">
-	<cfargument name="maximum" type="numeric" required="false" hint="The maximum length that the property value has to be.">
-	<cfargument name="minimum" type="numeric" required="false" hint="The minimum length that the property value has to be.">
-	<cfargument name="within" type="string" required="false" hint="A list of two values (minimum and maximum) that the length of the property value has to fall within.">
-	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
+	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validates">
+	<cfargument name="message" type="string" required="false" hint="See documentation for @validates.">
+	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validates.">
+	<cfargument name="allowBlank" type="boolean" required="false" hint="See documentation for @validates.">
+	<cfargument name="exactly" type="numeric" required="false" hint="See documentation for @validates">
+	<cfargument name="maximum" type="numeric" required="false" hint="See documentation for @validates">
+	<cfargument name="minimum" type="numeric" required="false" hint="See documentation for @validates">
+	<cfargument name="within" type="string" required="false" hint="See documentation for @validates">
+	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validates.">
 	<cfscript>
 		$insertDefaults(name="validatesLengthOf", input=arguments);
-		if (Len(arguments.within))
-			arguments.within = $listClean(list=arguments.within, returnAs="array");
-		$registerValidation(methods="$validateLengthOf", argumentCollection=arguments);
+		validates(argumentCollection=arguments);
 	</cfscript>
 </cffunction>
 
@@ -124,22 +162,25 @@
 		<cfset validatesNumericalityOf(property="score", onlyInteger=true, allowBlank=true, message="Please enter a correct score.")>
 	'
 	categories="model-initialization,validations" chapters="object-validation" functions="validatesConfirmationOf,validatesExclusionOf,validatesFormatOf,validatesInclusionOf,validatesLengthOf,validatesPresenceOf,validatesUniquenessOf">
-	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="message" type="string" required="false" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="allowBlank" type="boolean" required="false" hint="See documentation for @validatesExclusionOf.">
-	<cfargument name="onlyInteger" type="boolean" required="false" hint="Specifies whether the property value has to be an integer.">
-	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="odd" type="boolean" required="false" hint="Specifies the value must be an odd number.">
-	<cfargument name="even" type="boolean" required="false" hint="Specifies the value must be an even number.">
-	<cfargument name="greaterThan" type="numeric" required="false" hint="Specifies the value must be greater than the supplied value.">
-	<cfargument name="greaterThanOrEqualTo" type="numeric" required="false" hint="Specifies the value must be greater than or equal the supplied value.">
-	<cfargument name="equalTo" type="numeric" required="false" hint="Specifies the value must be equal to the supplied value.">
-	<cfargument name="lessThan" type="numeric" required="false" hint="Specifies the value must be less than the supplied value.">
-	<cfargument name="lessThanOrEqualTo" type="numeric" required="false" hint="Specifies the value must be less than or equal the supplied value.">
-	<cfset $insertDefaults(name="validatesNumericalityOf", input=arguments)>
-	<cfset $registerValidation(methods="$validateNumericalityOf", argumentCollection=arguments)>
+	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="message" type="string" required="false" hint="See documentation for @validates.">
+	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validates.">
+	<cfargument name="allowBlank" type="boolean" required="false" hint="See documentation for @validates.">
+	<cfargument name="onlyInteger" type="boolean" required="false" hint="See documentation for @validates.">
+	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="odd" type="boolean" required="false" hint="See documentation for @validates.">
+	<cfargument name="even" type="boolean" required="false" hint="See documentation for @validates.">
+	<cfargument name="greaterThan" type="numeric" required="false" hint="See documentation for @validates.">
+	<cfargument name="greaterThanOrEqualTo" type="numeric" required="false" hint="See documentation for @validates.">
+	<cfargument name="equalTo" type="numeric" required="false" hint="See documentation for @validates.">
+	<cfargument name="lessThan" type="numeric" required="false" hint="See documentation for @validates.">
+	<cfargument name="lessThanOrEqualTo" type="numeric" required="false" hint="See documentation for @validates.">
+	<cfscript>
+		$insertDefaults(name="validatesNumericalityOf", input=arguments);
+		arguments.numeric = true;
+		validates(argumentCollection=arguments);
+	</cfscript>
 </cffunction>
 
 <cffunction name="validatesPresenceOf" returntype="void" access="public" output="false" hint="Validates that the specified property exists and that its value is not blank."
@@ -149,13 +190,16 @@
 		<cfset validatesPresenceOf("emailAddress")>
 	'
 	categories="model-initialization,validations" chapters="object-validation" functions="validatesConfirmationOf,validatesExclusionOf,validatesFormatOf,validatesInclusionOf,validatesLengthOf,validatesNumericalityOf,validatesUniquenessOf">
-	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="message" type="string" required="false" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
-	<cfset $insertDefaults(name="validatesPresenceOf", input=arguments)>
-	<cfset $registerValidation(methods="$validatePresenceOf", argumentCollection=arguments)>
+	<cfargument name="properties" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="message" type="string" required="false" hint="See documentation for @validates.">
+	<cfargument name="when" type="string" required="false" default="onSave" hint="See documentation for @validates.">
+	<cfargument name="if" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validates.">
+	<cfscript>
+		$insertDefaults(name="validatesPresenceOf", input=arguments);
+		arguments.presence = true;
+		validates(argumentCollection=arguments);
+	</cfscript>
 </cffunction>
 
 <cffunction name="validatesUniquenessOf" returntype="void" access="public" output="false" hint="Validates that the value of the specified property is unique in the database table. Useful for ensuring that two users can't sign up to a website with identical screen names for example. When a new record is created a check is made to make sure that no record already exists in the database with the given value for the specified property. When the record is updated the same check is made but disregarding the record itself."
@@ -177,8 +221,8 @@
 	<cfargument name="unless" type="string" required="false" default="" hint="See documentation for @validatesConfirmationOf.">
 	<cfscript>
 		$insertDefaults(name="validatesUniquenessOf", input=arguments);
-		arguments.scope = $listClean(arguments.scope);
-		$registerValidation(methods="$validateUniquenessOf", argumentCollection=arguments);
+		arguments.unique = true;
+		validates(argumentCollection=arguments);
 	</cfscript>
 </cffunction>
 
@@ -358,20 +402,7 @@
 				loc.thisValidation = variables.wheels.class.validations[loc.type][loc.i];
 				if ($evaluateCondition(argumentCollection=loc.thisValidation.args))
 				{
-					if (loc.thisValidation.method == "$validatePresenceOf")
-					{
-						// if the property does not exist or if it's blank we add an error on the object (for all other validation types we call corresponding methods below instead)
-						if (!StructKeyExists(this, loc.thisValidation.args.property) || !Len(trim(this[loc.thisValidation.args.property])))
-							addError(property=loc.thisValidation.args.property, message=$validationErrorMessage(loc.thisValidation.args.property, loc.thisValidation.args.message));
-					}
-					else
-					{
-						// if the validation set does not allow blank values we can set an error right away, otherwise we call a method to run the actual check
-						if (StructKeyExists(loc.thisValidation.args, "property") && StructKeyExists(loc.thisValidation.args, "allowBlank") && !loc.thisValidation.args.allowBlank && (!StructKeyExists(this, loc.thisValidation.args.property) || !Len(this[loc.thisValidation.args.property])))
-							addError(property=loc.thisValidation.args.property, message=$validationErrorMessage(loc.thisValidation.args.property, loc.thisValidation.args.message));
-						else if (!StructKeyExists(loc.thisValidation.args, "property") || (StructKeyExists(this, loc.thisValidation.args.property) && Len(this[loc.thisValidation.args.property])))
-							$invoke(method=loc.thisValidation.method, argumentCollection=loc.thisValidation.args);
-					}
+					$invoke(method=loc.thisValidation.method, argumentCollection=loc.thisValidation.args);
 				}
 			}
 		}
@@ -381,129 +412,215 @@
 	<cfreturn loc.returnValue>
 </cffunction>
 
-<cffunction name="$evaluateCondition" returntype="boolean" access="public" output="false" hint="Evaluates the condition to determine if the validation should be executed.">
-	<cfscript>
-		var returnValue = false;
-		// proceed with validation when `if` has been supplied and it evaluates to `true` or when `unless` has been supplied and it evaluates to `false`
-		// if both `if` and `unless` have been supplied though, they both need to be evaluated correctly (`true`/`false` that is) for validation to proceed
-		if ((!StructKeyExists(arguments, "if") || !Len(arguments.if) || Evaluate(arguments.if)) && (!StructKeyExists(arguments, "unless") || !Len(arguments.unless) || !Evaluate(arguments.unless)))
-			returnValue = true;
-	</cfscript>
-	<cfreturn returnValue>
-</cffunction>
-
-<cffunction name="$validateConfirmationOf" returntype="void" access="public" output="false" hint="Adds an error if the object property fail to pass the validation setup in the @validatesConfirmationOf method.">
-	<cfscript>
-		var loc = {};
-		loc.virtualConfirmProperty = arguments.property & "Confirmation";
-		if (StructKeyExists(this, loc.virtualConfirmProperty) && this[arguments.property] != this[loc.virtualConfirmProperty])
-			addError(property=loc.virtualConfirmProperty, message=$validationErrorMessage(arguments.property, arguments.message));
-	</cfscript>
-</cffunction>
-
-<cffunction name="$validateExclusionOf" returntype="void" access="public" output="false" hint="Adds an error if the object property fail to pass the validation setup in the @validatesExclusionOf method.">
-	<cfscript>
-		if (ListFindNoCase(arguments.list, this[arguments.property]))
-			addError(property=arguments.property, message=$validationErrorMessage(arguments.property, arguments.message));
-	</cfscript>
-</cffunction>
-
-<cffunction name="$validateFormatOf" returntype="void" access="public" output="false" hint="Adds an error if the object property fail to pass the validation setup in the @validatesFormatOf method.">
-	<cfscript>
-		if ((Len(arguments.regEx) && !REFindNoCase(arguments.regEx, this[arguments.property])) || (Len(arguments.type) && !IsValid(arguments.type, this[arguments.property])))
-			addError(property=arguments.property, message=$validationErrorMessage(arguments.property, arguments.message));
-	</cfscript>
-</cffunction>
-
-<cffunction name="$validateInclusionOf" returntype="void" access="public" output="false" hint="Adds an error if the object property fail to pass the validation setup in the @validatesInclusionOf method.">
-	<cfscript>
-		if (!ListFindNoCase(arguments.list, this[arguments.property]))
-			addError(property=arguments.property, message=$validationErrorMessage(arguments.property, arguments.message));
-	</cfscript>
-</cffunction>
-
-<cffunction name="$validateLengthOf" returntype="void" access="public" output="false" hint="Adds an error if the object property fail to pass the validation setup in the @validatesLengthOf method.">
+<cffunction name="$validates" returntype="void" access="public" output="false">
 	<cfscript>
-		if (arguments.maximum)
+	var loc = {};
+	loc.isvalid = true;
+	loc.validation = [];
+	loc.errorProperty = arguments.property;
+	// make sure that the property exists
+	if (IsBoolean(arguments.presence) && (!StructKeyExists(this, arguments.property) || !Len(trim(this[arguments.property]))))
+	{
+		ArrayAppend(loc.validation, "presence");
+		loc.isvalid = false;
+	}
+
+	// allowBlank
+	if (loc.isvalid && IsBoolean(arguments.allowBlank) && (StructKeyExists(arguments, "property") && !arguments.allowBlank && (!StructKeyExists(this, arguments.property) || !Len(this[arguments.property]))))
+	{
+		ArrayAppend(loc.validation, "allowBlank");
+		loc.isvalid = false;
+	}
+
+	if (loc.isvalid && (!StructKeyExists(arguments, "property") || (StructKeyExists(this, arguments.property) && Len(this[arguments.property]))))
+	{
+
+		// confirmation
+		if (loc.isvalid && Len(arguments.confirm))
+		{
+			// what virtual property are we confirming against
+			if (IsBoolean(arguments.confirm))
+			{
+				arguments.confirm = arguments.property & "Confirmation";
+			}
+			if (StructKeyExists(this, arguments.confirm) && this[arguments.property] != this[arguments.confirm])
+			{
+				arguments.property = arguments.confirm;
+				ArrayAppend(loc.validation, "confirmation");
+				loc.isvalid = false;
+			}
+		}
+		// exclusion
+		if (loc.isvalid && Len(arguments.exclusion))
 		{
-			if (Len(this[arguments.property]) gt arguments.maximum)
-				addError(property=arguments.property, message=$validationErrorMessage(arguments.property, arguments.message));
+			arguments.exclusion = $listClean(arguments.exclusion);
+			if (ListFindNoCase(arguments.exclusion, this[arguments.property]))
+			{
+				ArrayAppend(loc.validation, "exclusion");
+				loc.isvalid = false;
+			}
 		}
-		else if (arguments.minimum)
+		// inclusion
+		if (loc.isvalid && Len(arguments.inclusion))
 		{
-			if (Len(this[arguments.property]) lt arguments.minimum)
-				addError(property=arguments.property, message=$validationErrorMessage(arguments.property, arguments.message));
+			arguments.inclusion = $listClean(arguments.inclusion);
+			if (!ListFindNoCase(arguments.inclusion, this[arguments.property]))
+			{
+				ArrayAppend(loc.validation, "inclusion");
+				loc.isvalid = false;
+			}
 		}
-		else if (arguments.exactly)
+		// maximum
+		if (loc.isvalid && Len(arguments.maximum) && arguments.maximum && Len(this[arguments.property]) gt arguments.maximum)
 		{
-			if (Len(this[arguments.property]) neq arguments.exactly)
-				addError(property=arguments.property, message=$validationErrorMessage(arguments.property, arguments.message));
+			ArrayAppend(loc.validation, "maximum");
+			loc.isvalid = false;
 		}
-		else if (IsArray(arguments.within) && ArrayLen(arguments.within))
+		// minimum
+		if (loc.isvalid && Len(arguments.minimum) && arguments.minimum && Len(this[arguments.property]) lt arguments.minimum)
 		{
-			if (Len(this[arguments.property]) lt arguments.within[1] or Len(this[arguments.property]) gt arguments.within[2])
-				addError(property=arguments.property, message=$validationErrorMessage(arguments.property, arguments.message));
+			ArrayAppend(loc.validation, "minimum");
+			loc.isvalid = false;
 		}
-	</cfscript>
-</cffunction>
-
-<cffunction name="$validateNumericalityOf" returntype="void" access="public" output="false" hint="Adds an error if the object property fail to pass the validation setup in the @validatesNumericalityOf method.">
-	<cfscript>
-		if (
-			!IsNumeric(this[arguments.property])
-			|| (arguments.onlyInteger && Round(this[arguments.property]) != this[arguments.property])
-			|| (IsNumeric(arguments.greaterThan) && this[arguments.property] lte arguments.greaterThan)
-			|| (IsNumeric(arguments.greaterThanOrEqualTo) && this[arguments.property] lt arguments.greaterThanOrEqualTo)
-			|| (IsNumeric(arguments.equalTo) && this[arguments.property] neq arguments.equalTo)
-			|| (IsNumeric(arguments.lessThan) && this[arguments.property] gte arguments.lessThan)
-			|| (IsNumeric(arguments.lessThanOrEqualTo) && this[arguments.property] gt arguments.lessThanOrEqualTo)
-			|| (IsBoolean(arguments.odd) && arguments.odd && !BitAnd(this[arguments.property], 1))
-			|| (IsBoolean(arguments.even) && arguments.even && BitAnd(this[arguments.property], 1))
-		){
-			addError(property=arguments.property, message=$validationErrorMessage(arguments.property, arguments.message));
+		// exactly
+		if (loc.isvalid && Len(arguments.exactly) && arguments.exactly && Len(this[arguments.property]) neq arguments.exactly)
+		{
+			ArrayAppend(loc.validation, "exactly");
+			loc.isvalid = false;
 		}
-	</cfscript>
-</cffunction>
+		// within
+		if (loc.isvalid && Len(arguments.within) && (Len(this[arguments.property]) lt ListFirst(arguments.within) or Len(this[arguments.property]) gt ListRest(arguments.within)))
+		{
+			ArrayAppend(loc.validation, "within");
+			loc.isvalid = false;
+		}
+		// regex
+		if (loc.isvalid && Len(arguments.regex) && !REFindNoCase(arguments.regEx, this[arguments.property]))
+		{
+			ArrayAppend(loc.validation, "regex");
+			loc.isvalid = false;
+		}
+		// format
+		if (loc.isvalid && Len(arguments.format) && !IsValid(arguments.format, this[arguments.property]))
+		{
+			ArrayAppend(loc.validation, "format");
+			loc.isvalid = false;
+		}
+		// numeric
+		if (loc.isvalid && IsBoolean(arguments.numeric) && arguments.numeric && !IsNumeric(this[arguments.property]))
+		{
+			ArrayAppend(loc.validation, "numeric");
+			loc.isvalid = false;
+		}
+		// onlyInteger
+		if (loc.isvalid && IsBoolean(arguments.onlyInteger) && arguments.onlyInteger && Round(this[arguments.property]) != this[arguments.property])
+		{
+			ArrayAppend(loc.validation, "onlyInteger");
+			loc.isvalid = false;
+		}
+		// greaterThan
+		if (loc.isvalid && IsNumeric(arguments.greaterThan) && this[arguments.property] lte arguments.greaterThan)
+		{
+			ArrayAppend(loc.validation, "greaterThan");
+			loc.isvalid = false;
+		}
+		// greaterThanOrEqualTo
+		if (loc.isvalid && IsNumeric(arguments.greaterThanOrEqualTo) && this[arguments.property] lt arguments.greaterThanOrEqualTo)
+		{
+			ArrayAppend(loc.validation, "greaterThanOrEqualTo");
+			loc.isvalid = false;
+		}
+		// equalTo
+		if (loc.isvalid && IsNumeric(arguments.equalTo) && this[arguments.property] neq arguments.equalTo)
+		{
+			ArrayAppend(loc.validation, "equalTo");
+			loc.isvalid = false;
+		}
+		// lessThan
+		if (loc.isvalid && IsNumeric(arguments.lessThan) && this[arguments.property] gte arguments.lessThan)
+		{
+			ArrayAppend(loc.validation, "lessThan");
+			loc.isvalid = false;
+		}
+		// lessThanOrEqualTo
+		if (loc.isvalid && IsNumeric(arguments.lessThanOrEqualTo) && this[arguments.property] gt arguments.lessThanOrEqualTo)
+		{
+			ArrayAppend(loc.validation, "lessThanOrEqualTo");
+			loc.isvalid = false;
+		}
+		// odd
+		if (loc.isvalid && IsBoolean(arguments.odd) && arguments.odd && !BitAnd(this[arguments.property], 1))
+		{
+			ArrayAppend(loc.validation, "odd");
+			loc.isvalid = false;
+		}
+		// even
+		if (loc.isvalid && IsBoolean(arguments.even) && arguments.even && BitAnd(this[arguments.property], 1))
+		{
+			ArrayAppend(loc.validation, "even");
+			loc.isvalid = false;
+		}
+		// unique
+		if(loc.isvalid && Len(arguments.unique) && arguments.unique )
+		{
+			// create the WHERE clause to be used in the query that checks if an identical value already exists
+			// wrap value in single quotes unless it's numeric
+			// example: "userName='Joe'"
+			loc.where = arguments.property & "=";
+			if (!IsNumeric(this[arguments.property]))
+				loc.where = loc.where & "'";
+			loc.where = loc.where & this[arguments.property];
+			if (!IsNumeric(this[arguments.property]))
+				loc.where = loc.where & "'";
+
+			// add scopes to the WHERE clause if passed in, this means that checks for other properties are done in the WHERE clause as well
+			// example: "userName='Joe'" becomes "userName='Joe' AND account=1" if scope is "account" for example
+			if (Len(arguments.scope))
+			{
+				arguments.scope = $listClean(arguments.scope);
+				loc.iEnd = ListLen(arguments.scope);
+				for (loc.i=1; loc.i <= loc.iEnd; loc.i++)
+				{
+					loc.where = loc.where & " AND ";
+					loc.property = Trim(ListGetAt(arguments.scope, loc.i));
+					loc.where = loc.where & loc.property & "=";
+					if (!IsNumeric(this[loc.property]))
+						loc.where = loc.where & "'";
+					loc.where = loc.where & this[loc.property];
+					if (!IsNumeric(this[loc.property]))
+						loc.where = loc.where & "'";
+				}
+			}
 
-<cffunction name="$validateUniquenessOf" returntype="void" access="public" output="false" hint="Adds an error if the object property fail to pass the validation setup in the @validatesUniquenessOf method.">
-	<cfscript>
-		var loc = {};
+			// try to fetch existing object from the database
+			loc.existingObject = findOne(where=loc.where, reload=true);
 
-		// create the WHERE clause to be used in the query that checks if an identical value already exists
-		// wrap value in single quotes unless it's numeric
-		// example: "userName='Joe'"
-		loc.where = arguments.property & "=";
-		if (!IsNumeric(this[arguments.property]))
-			loc.where = loc.where & "'";
-		loc.where = loc.where & this[arguments.property];
-		if (!IsNumeric(this[arguments.property]))
-			loc.where = loc.where & "'";
-
-		// add scopes to the WHERE clause if passed in, this means that checks for other properties are done in the WHERE clause as well
-		// example: "userName='Joe'" becomes "userName='Joe' AND account=1" if scope is "account" for example
-		if (Len(arguments.scope))
-		{
-			loc.iEnd = ListLen(arguments.scope);
-			for (loc.i=1; loc.i <= loc.iEnd; loc.i++)
+			// we add an error if an object was found in the database and the current object is either not saved yet or not the same as the one in the database
+			if (IsObject(loc.existingObject) && (isNew() || loc.existingObject.key() != key($persisted=true)))
 			{
-				loc.where = loc.where & " AND ";
-				loc.property = Trim(ListGetAt(arguments.scope, loc.i));
-				loc.where = loc.where & loc.property & "=";
-				if (!IsNumeric(this[loc.property]))
-					loc.where = loc.where & "'";
-				loc.where = loc.where & this[loc.property];
-				if (!IsNumeric(this[loc.property]))
-					loc.where = loc.where & "'";
+				ArrayAppend(loc.validation, "unique");
+				loc.isvalid = false;
 			}
 		}
+	}
 
-		// try to fetch existing object from the database
-		loc.existingObject = findOne(where=loc.where, reload=true);
+	// add error if not valid
+	if (!loc.isvalid)
+	{
+		addError(property="#arguments.property#", message="#$validationErrorMessage(loc.errorProperty, arguments.message)#");
+	}
+	</cfscript>
+</cffunction>
 
-		// we add an error if an object was found in the database and the current object is either not saved yet or not the same as the one in the database
-		if (IsObject(loc.existingObject) && (isNew() || loc.existingObject.key() != key($persisted=true)))
-			addError(property=arguments.property, message=$validationErrorMessage(arguments.property, arguments.message));
+<cffunction name="$evaluateCondition" returntype="boolean" access="public" output="false" hint="Evaluates the condition to determine if the validation should be executed.">
+	<cfscript>
+		var returnValue = false;
+		// proceed with validation when `if` has been supplied and it evaluates to `true` or when `unless` has been supplied and it evaluates to `false`
+		// if both `if` and `unless` have been supplied though, they both need to be evaluated correctly (`true`/`false` that is) for validation to proceed
+		if ((!StructKeyExists(arguments, "if") || !Len(arguments.if) || Evaluate(arguments.if)) && (!StructKeyExists(arguments, "unless") || !Len(arguments.unless) || !Evaluate(arguments.unless)))
+			returnValue = true;
 	</cfscript>
+	<cfreturn returnValue>
 </cffunction>
 
 <cffunction name="$validationExists" returntype="boolean" access="public" output="false" hint="Checks to see if a validation has been created for a property.">
diff --git a/wheels/tests/model/validations/low_level_validations.cfc b/wheels/tests/model/validations/low_level_validations.cfc
index d6b1494..eac1190 100644
--- a/wheels/tests/model/validations/low_level_validations.cfc
+++ b/wheels/tests/model/validations/low_level_validations.cfc
@@ -8,7 +8,7 @@
 		<cfset assert('StructKeyExists(loc.user, "_validateOnCreateCalled")')>
 		<cfset assert('loc.user._validateOnCreateCalled eq true')>
 	</cffunction>
-	
+
 	<cffunction name="test_validate_and_validateOnUpdate_should_be_called_when_updating">
 		<cfset loc.user = model("user").findOne(where="username = 'perd'")>
 		<cfset loc.user.valid()>
-- 
1.6.1.2

